#!/usr/bin/python3

###############################################################
# PERSISTENCE LANDSCAPES
# Convert persistence diagram to persistence landscape
# For formula/method used, see 
# https://people.clas.ufl.edu/peterbubenik/files/intro_tda_worksheet.pdf
#
# Calder Sheagren
# University of Toronto
# calder.sheagren@sri.utoronto.ca
# Date: December 23, 2020
###############################################################

import numpy as np

def to_landscape(diagram):
    """
    Function to convert a persistence diagram generated by ripser, cechmate, ... into
    a persistence landscape. Can accomodate arbitrary homology degree

    Inputs:
    -------
        diagram (list): output of ripser, cechmate, ...

    Returns:
    --------
        global_landscapes (list of tuples): each entry is a tuple (x, landscapes)
            - x (np.array): the relevant domain (support) where not all landscape functions are zero
            - landscapes (list): a list of persistence landscape functions
    """

    global_landscapes = []

    for dgm in diagram:

        # load in birth and death points

        birth = dgm[:,0]
        death = dgm[:,1]

        # remove infinity points

        if np.inf in death:
            ind = np.where(death == np.inf)
            death = np.delete(death, ind)
            birth = np.delete(birth, ind)

        if np.inf in birth:
            ind = np.where(birth == np.inf)
            birth = np.delete(birth, ind)
            death = np.delete(death, ind)

        # landscape is zero outside the interval
        # [min(birth), max(death)]

        min_birth = np.min(birth)
        max_death = np.max(death)

        # compute hat functions

        x = np.linspace(min_birth, max_death, 1000)
        triangles = np.array([[hat(pt, b, d) for pt in x ] for b, d in zip(birth, death)])

        # sort triangles to get landscape
        landscapes = np.sort(triangles, axis=0)[::-1]

        # append tuple to overall list
        global_landscapes.append((x, landscapes))

    return global_landscapes


def hat(t, b, d):
    """
    Calculate output of piecewise linear hat function at position x, birth b, death d

    Inputs:
    -------
        t: position (float)
        b: birth (float)
        d: death (float)

    Returns:
    -------
        v: value of f_b,d(t)
    """
    #TODO speed up with numpy?

    if t >= b and t <= (b + d)/2.:
        return t - b

    elif t > (b + d)/2. and t <= d:
        return d - t

    else:
        return 0




